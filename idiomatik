#!/usr/bin/env python3

# GOAL :
#Model = { 'R0 : A = B <=> B = A (swap)', 'P0 : "a" = "b"', 'P1 : "b" = "c"' }
#CHECK P1 : "a" = "c"

#RULES['AXIOMS'].append(RULE[1])
#RULES['REWRITE_RULES'].append(RULE[1])

import sys
from read_table import *
from lexer import *
from parser import *
from read_rules import *
from checker import *
from displayer import *
from rewriter import *
import readline # allow left/right arrow while inputing

sys.setrecursionlimit(10**6)

# https://stackoverflow.com/a/287944
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    #ERASE_LINE = '\r\033[0K'
    #ERASE_UP= '\r\033\[1A'
# print(bcolors.WARNING + "Warning: No active frommets remain. Continue?" + bcolors.ENDC)


global last_proposition
global user_propositions
user_propositions = []

#IDIOMATIK_PROMPT   = '|> '
#IDIOMATIK_GREETING = '''
#+----------------------------------------------------------------------------+
#|> Welcome to idiomatik! You can start writing expressions as inputs.        |
#|  Read the documentation (if any) to learn about commands.                  |
#+----------------------------------------------------------------------------+
#'''
IDIOMATIK_PROMPT   = bcolors.OKGREEN + '|> ' + bcolors.ENDC
IDIOMATIK_GREETING = bcolors.OKBLUE + '''
+----------------------------------------------------------------------------+
|> Welcome to idiomatik! You can start writing expressions as inputs.        |
|  Read the documentation (if any) to learn about commands.                  |
+----------------------------------------------------------------------------+
''' + bcolors.ENDC

def evaluate_proposition(PROP):
    global last_proposition
    '''
    If PROP starts with ':' then it is a COMMAND
    '''
    if PROP[0:1] == ":":
        PROP = PROP.split(' ')
        match PROP[0]:
            case ":q" | ":quit" | ":exit" :
                exit(0)
            case ":t" | ":token":
                try:
                    print(TOKENIZE(last_proposition))
                except:
                    print(bcolors.FAIL + "ERROR: you need to give an expression first." + bcolors.ENDC)
            case ":T" | ":tree":
                try :
                    render_tree(TOKENIZE(last_proposition))
                except:
                    print("ERROR: why no tree? TODO")
            case ":s" | ":surrounding" :
                try :
                    solving_surrounders = NULL.join(map(str, [x[1] for x in silent_surrounding(TOKENIZE(last_proposition))]))
                    print("Background surrounding : {}".format(solving_surrounders))
                except:
                    print("ERROR: you need to give an expression first.")
            case ":A" | ":axioms":
                display_axioms_and_rules("axioms")
            case ":R" | ":rules":
                display_axioms_and_rules("rules")
            case ":r" | ":rewrite":
                #try :
                display_all_possible_rewritings(last_proposition)
                #rewrite_token(last_proposition)
                #except :
                #    print("ERROR: you need to give an expression first.")
            case ":p" | ":parts": # rewritable parts of the token
                display_rewritable_parts(last_proposition)
                #print(TOKENIZE(last_proposition))
                #print(human_readable(token_all_rewritable_parts(TOKENIZE(last_proposition))))
            case ":h" | ":help":
                print("TODO: sorry, this help menu is not really helpful for now.")
            case ":add" :
                if len(PROP) == 1 or len(PROP) > 2 : print("ERROR: ':add' needs precisely of those arguments: 'axiom', 'rule', 'proposition'")
                else :
                    match PROP[1]:
                        case "axiom" | "a" :
                            if TOKENIZE(last_proposition) in RULES['AXIOMS'] : print("Axiom already stored!")
                            else : RULES['AXIOMS'].append(TOKENIZE(last_proposition))
                        case "rule" | "r":
                            REWRITE_SYMBOL = SYMBOLS['OPERATORS'][SYMBOLS['OPERATORS NAMES'].index("REWRITE_AS")]
                            if REWRITE_SYMBOL in last_proposition :
                                if TOKENIZE(last_proposition) in RULES['REWRITE_RULES'] : print("Rule already stored!")
                                else : RULES['REWRITE_RULES'].append(TOKENIZE(last_proposition))
                            else :
                                print("ERROR: rules need the rewrite symbol.")
                        case "prop" | "p" | "proposition":
                            print("TODO")
            case _:
                print("ERROR: unknown command. See '{} --help' or ':help'.".format(sys.argv[0]))

    else :
        cur_proposition = str(PROP)
        if PARSE(TOKENIZE(cur_proposition))[0]:
            last_proposition = cur_proposition
            user_propositions.append(last_proposition)
            #REWRITE_SYMBOL = "-->"
            #if REWRITE_SYMBOL in cur_proposition :
            #    if TOKENIZE(cur_proposition) in RULES['REWRITE_RULES'] : print("Rule already stored!")
            #    else : RULES['REWRITE_RULES'].append(TOKENIZE(cur_proposition))
            #else :
            #    if TOKENIZE(cur_proposition) in RULES['AXIOMS'] : print("Axiom already stored!")
            #    else : RULES['AXIOMS'].append(TOKENIZE(cur_proposition))
        else:
            print("ERROR: invalid syntax. TODO : say more about error.")

try :
    if sys.argv[1] :
        print("TODO: {} will soon accept receiving arguments.\n".format(sys.argv[0]))
except:
    pass

print(IDIOMATIK_GREETING)

while True:
    try :
        user_input = input(IDIOMATIK_PROMPT)
    except:
        print("Error decoding input. Invalid characters might have went by. Please type again!")
        continue
    proposition=str(user_input)
    evaluate_proposition(proposition)
