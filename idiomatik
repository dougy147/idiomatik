#!/usr/bin/env python3

# GOAL :
#Model = { 'R0 : A = B <=> B = A (swap)', 'P0 : "a" = "b"', 'P1 : "b" = "c"' }
#CHECK P1 : "a" = "c"

#RULES['AXIOMS'].append(RULE[1])
#RULES['REWRITE_RULES'].append(RULE[1])

import sys
from read_table import *
from lexer import *
from parser import *
from read_rules import *
from checker import *
from displayer import *
from rewriter import *
import readline # allow left/right arrow while inputing
from colors import *

sys.setrecursionlimit(10**6)

global last_proposition
last_proposition = ""
global user_propositions
user_propositions = []

IDIOMATIK_PROMPT   = bcolors.OKGREEN + '|> ' + bcolors.ENDC
IDIOMATIK_GREETING = bcolors.OKBLUE + '''
+----------------------------------------------------------------------------+
|> Welcome to idiomatik! You can start writing expressions as inputs.        |
|  Read the documentation (if any) to learn about commands.                  |
+----------------------------------------------------------------------------+
''' + bcolors.ENDC

def add_rule(multiple=False,added_rules_number=0,last_proposition=last_proposition):
    if multiple == True:
        try :
            last_proposition = input("    > ")
        except:
            print(bcolors.FAIL + "ERROR: Invalid characters in input." + bcolors.ENDC)
        if last_proposition == "" or last_proposition == ":q" :
            print(bcolors.ERASE_LINE + bcolors.ERASE_UP + bcolors.ERASE_LINE) # Erase empty prompt
            #print(bcolors.ERASE_LINE + bcolors.ERASE_UP +bcolors.ERASE_LINE)
            #s="s"
            #if added_rules_number == 0 : added_rules_number,s = "No",""
            #elif added_rules_number == 1 : s = ""
            #print(bcolors.OKBLUE + "{} rule{} added.".format(added_rules_number,s) + bcolors.ENDC)
            #print(bcolors.ERASE_LINE) # Erase empty prompt
            return
    REWRITE_SYMBOL = SYMBOLS['OPERATORS'][SYMBOLS['OPERATORS NAMES'].index("REWRITE_AS")]
    #print(last_proposition)
    if REWRITE_SYMBOL in last_proposition :
        if TOKENIZE(last_proposition) in RULES['REWRITE_RULES'] :
            print(bcolors.WARNING + "Rule already stored!" + bcolors.ENDC)
            if added_rules_number > 0 : added_rules_number-=1
        else : RULES['REWRITE_RULES'].append(TOKENIZE(last_proposition))
    else :
        print(bcolors.FAIL + "Rules need the rewrite symbol '" + str(REWRITE_SYMBOL) + "'." + bcolors.ENDC)
        if added_rules_number > 0 : added_rules_number-=1
    if multiple :
        add_rule(multiple=True,added_rules_number=added_rules_number+1)

def evaluate_proposition(PROP):
    global last_proposition
    '''
    If PROP starts with ':' then it is a COMMAND?
    '''
    #if PROP[0:1] == ":":
    #PROP = PROP.split(' ')
    match PROP.split(' ')[0]:
        case ":q" | "quit" | "exit" :
            exit(0)
        case "prop" | "proposition": # displays current proposition under scrutiny
            print(human_readable(TOKENIZE(last_proposition)))
        case "tok" | "token":
            try:
                print(TOKENIZE(last_proposition))
            except:
                print(bcolors.FAIL + "ERROR: you need to give an expression first." + bcolors.ENDC)
        case "tree" | "draw" :
            try :
                render_tree(TOKENIZE(last_proposition))
            except:
                print("ERROR: why no tree? TODO")
        case "surr" | "surrounding" :
            try :
                #solving_surrounders = NULL.join(map(str, [x[1] for x in silent_surrounding(TOKENIZE(last_proposition))]))
                solving_surrounders = human_readable(silent_surrounding(TOKENIZE(last_proposition)))
                print("Background surrounding : {}".format(solving_surrounders))
            except:
                print("ERROR: you need to give an expression first.")
        case "axioms":
            display_axioms_and_rules("axioms")
        case "rules":
            display_axioms_and_rules("rules")
        case "rewrite":
            if len(PROP.split(' ')) < 2 :
                    print(bcolors.WARNING + "Please provide a name or number for rewriting rule.\n Or use 'full' to combine them all." + bcolors.ENDC)
            else :
                match PROP.split(' ')[1]:
                    case "full" | "f" :
                        display_all_possible_rewritings(last_proposition)
                    case _ :
                        print(bcolors.WARNING + "TODO: something else than full rewrite" + bcolors.ENDC)
        case "match": # highlight rewritable parts of the token
            if len(PROP.split(' ')) == 2 :
                rule_index = PROP.split(' ')[1].replace('r','').replace('R','')
                display_single_rewritable_parts(last_proposition,RULE_INDEX=rule_index)
            else :
                display_rewritable_parts(last_proposition)
        case "help":
            print("TODO: sorry, this help menu is not really helpful for now.")
        case "debug" :
            if len(PROP.split(' ')) != 2 :
                print("Need one thing to debug. For example : debug rules")
            else :
                match PROP.split(' ')[1] :
                    case "rules" : print(RULES)
                    case "rewrite" : print(RULES['REWRITE_RULES'])
                    case "axioms" : print(RULES['AXIOMS'])
        case "del" | "delete":
            if len(PROP.split(' ')) == 1 :
                print("INFO: Use 'delete x' or 'delete Rx' to delete a rule.")
                for i in range(len(RULES['REWRITE_RULES'])) :
                    print(bcolors.OKBLUE + "\t(R{}) {}".format(i,human_readable(RULES['REWRITE_RULES'][i])) + bcolors.ENDC)
            elif len(PROP.split(' ')) > 2 :
                print("ERROR: 'delete' needs precisely one rule number")
            else :
                for i in range(len(RULES['REWRITE_RULES'])) :
                    if "R"+str(i) == PROP.split(' ')[1] or \
                        "r"+str(i) == PROP.split(' ')[1] or \
                        str(i) == PROP.split(' ')[1] :
                            #print(RULES['REWRITE_RULES'])
                            print(bcolors.OKBLUE + "Deleted (R{}) {}".format(i,human_readable(RULES['REWRITE_RULES'][i])) + bcolors.ENDC)
                            RULES['REWRITE_RULES'].pop(i)
        case "add" :
            if len(PROP.split(' ')) == 1 or len(PROP.split(' ')) > 2 : print("ERROR: ':add' needs precisely of those arguments: 'axiom', 'rule', 'proposition'")
            else :
                match PROP.split(' ')[1]:
                    case "axiom" | "a" :
                        if TOKENIZE(last_proposition) in RULES['AXIOMS'] : print("Axiom already stored!")
                        else : RULES['AXIOMS'].append(TOKENIZE(last_proposition))
                    case "rule" | "r":
                        add_rule(multiple=False,last_proposition=last_proposition)
                    case "rules" | "rs":
                        add_rule(multiple=True)
                    case "prop" | "p" | "proposition":
                        print("TODO")
        case _:
            #print(bcolors.FAIL + "ERROR: unknown command. See '{} --help' or ':help'.".format(sys.argv[0]) + bcolors.ENDC)
            cur_proposition = str(PROP)
            if PARSE(TOKENIZE(cur_proposition))[0]:
                last_proposition = cur_proposition
                user_propositions.append(last_proposition)
            else:
                print(bcolors.FAIL + "ERROR: invalid syntax. TODO : say more about error." + bcolors.ENDC)

try :
    if sys.argv[1] :
        print(bcolors.OKBLUE + "TODO: {} will soon accept receiving arguments.".format(sys.argv[0]) + bcolors.ENDC)
except:
    pass

print(IDIOMATIK_GREETING)

while True:
    try :
        user_input = input(IDIOMATIK_PROMPT)
    except:
        print(bcolors.FAIL + "ERROR: Invalid characters in input." + bcolors.ENDC)
        continue
    proposition=str(user_input)
    evaluate_proposition(proposition)
