#!/usr/bin/env python3

# GOAL :
#Model = { 'R0 : A = B <=> B = A (swap)', 'P0 : "a" = "b"', 'P1 : "b" = "c"' }
#CHECK P1 : "a" = "c"

#RULES['AXIOMS'].append(RULE[1])
#RULES['REWRITE_RULES'].append(RULE[1])

import sys
from read_table import *
from lexer import *
from parser import *
from read_rules import *
from checker import *
from displayer import *
from rewriter import *
import readline # allow left/right arrow while inputing
from colors import *

sys.setrecursionlimit(10**6)

global last_proposition
last_proposition = ""
global user_propositions
user_propositions = []

IDIOMATIK_PROMPT   = bcolors.OKGREEN + '\n|> ' + bcolors.ENDC
IDIOMATIK_GREETING = bcolors.OKBLUE + '''
+---------------------------------------------------------------------+
|> Welcome to idiomatik! You can start writing expressions as inputs. |
|            Read the documentation (if any) to learn about commands. |
+---------------------------------------------------------------------+
''' + bcolors.ENDC

def add_rule(multiple=False,last_proposition=last_proposition):
    if multiple == True:
        try :
            last_proposition = input("    > ")
        except:
            print(bcolors.FAIL + "ERROR: Invalid characters in input." + bcolors.ENDC)
        if last_proposition == "" or last_proposition == ":q" :
            print(bcolors.ERASE_LINE + bcolors.ERASE_UP + bcolors.ERASE_LINE) # Erase empty prompt
            return
    elif last_proposition.replace(NULL,'') == "" :
        print("ERROR: empty proposition")
        return
    READ_RULES([last_proposition],add_axioms=False)
    if multiple :
        add_rule(multiple=True)

def add_axiom(multiple=False,last_proposition=last_proposition):
    if multiple == True:
        try :
            last_proposition = input("    > ")
        except:
            print(bcolors.FAIL + "ERROR: Invalid characters in input." + bcolors.ENDC)
        if last_proposition == "" or last_proposition == ":q" :
            print(bcolors.ERASE_LINE + bcolors.ERASE_UP + bcolors.ERASE_LINE) # Erase empty prompt
            return
    elif last_proposition.replace(NULL,'') == "" :
        print("ERROR: empty proposition")
        return
    READ_RULES([last_proposition],add_rules=False)
    if multiple :
        add_axiom(multiple=True)


def del_rule_or_axiom(user_value):
    # user_value = PROP.split(' ')[1]
    found = False
    for i in range(len(RULES['REWRITE_RULES'])) :
        if "R"+str(i) == user_value or \
            "r"+str(i) == user_value or \
            str(i) == user_value :
                found = True
                name = RULES['REWRITE_RULES_NAMES'][i]
                if name == "" :
                    print(bcolors.OKBLUE + "Deleted R{} {}".format(i,human_readable(RULES['REWRITE_RULES'][i])) + bcolors.ENDC)
                else :
                    print(bcolors.OKBLUE + "Deleted R{} ({}) {}".format(i,name,human_readable(RULES['REWRITE_RULES'][i])) + bcolors.ENDC)
                RULES['REWRITE_RULES'].pop(i)
                RULES['REWRITE_RULES_NAMES'].pop(i)
                break
    if found: return
    for i in range(len(RULES['REWRITE_RULES_NAMES'])) :
        if user_value == RULES['REWRITE_RULES_NAMES'][i] :
                name = RULES['REWRITE_RULES_NAMES'][i]
                print(bcolors.OKBLUE + "Deleted '{}' (R{}) {}".format(name,i,human_readable(RULES['REWRITE_RULES'][i])) + bcolors.ENDC)
                RULES['REWRITE_RULES_NAMES'].pop(i)
                RULES['REWRITE_RULES'].pop(i)
                break
    if found: return
    for i in range(len(RULES['AXIOMS'])) :
        if "A"+str(i) == user_value or \
            "a"+str(i) == user_value or \
            str(i) == user_value :
                found = True
                name = RULES['AXIOMS_NAMES'][i]
                if name == "" :
                    print(bcolors.OKBLUE + "Deleted R{} {}".format(i,human_readable(RULES['AXIOMS'][i])) + bcolors.ENDC)
                else :
                    print(bcolors.OKBLUE + "Deleted R{} ({}) {}".format(i,name,human_readable(RULES['AXIOMS'][i])) + bcolors.ENDC)
                RULES['AXIOMS'].pop(i)
                RULES['AXIOMS_NAMES'].pop(i)
                break
    if found: return
    for i in range(len(RULES['AXIOMS_NAMES'])) :
        if user_value == RULES['AXIOMS_NAMES'][i] :
                name = RULES['AXIOMS_NAMES'][i]
                print(bcolors.OKBLUE + "Deleted '{}' (A{}) {}".format(name,i,human_readable(RULES['AXIOMS'][i])) + bcolors.ENDC)
                RULES['AXIOMS_NAMES'].pop(i)
                RULES['AXIOMS'].pop(i)
                break

def evaluate_proposition(PROP):
    global last_proposition
    '''
    If PROP starts with ':' then it is a COMMAND?
    '''
    #if PROP[0:1] == ":":
    #PROP = PROP.split(' ')
    match PROP.split(' ')[0]:
        case ":q" | "quit" | "exit" :
            exit(0)
        case "prop" | "proposition": # displays current proposition under scrutiny
            print(human_readable(TOKENIZE(last_proposition)))
        case "tok" | "token":
            print(TOKENIZE(last_proposition))
        case "tree" | "draw" :
            try :
                render_tree(TOKENIZE(last_proposition))
            except:
                print(bcolors.FAIL + "ERROR: why no tree? TODO" + bcolors.ENDC)
        case "surr" | "surrounding" :
            solving_surrounders = human_readable(silent_surrounding(TOKENIZE(last_proposition)))
            print("{}".format(solving_surrounders))
        case "axioms":
            display_axioms_and_rules("axioms")
        case "rules":
            display_axioms_and_rules("rules")

        case "rewrite":
            if len(PROP.split(' ')) == 1 :
                    print(bcolors.WARNING + "Please provide a name or number for rewriting rule.\nOr use 'full' to combine them all." + bcolors.ENDC)
            elif len(PROP.split(' ')) == 2 :
                match PROP.split(' ')[1]:
                    case "full" | "f" :
                        display_all_possible_rewritings(last_proposition)
                    case _ :
                        rule_or_index = PROP.split(' ')[1]
                        is_rule = False
                        for i in range(len(RULES['REWRITE_RULES_NAMES'])):
                            if rule_or_index == RULES['REWRITE_RULES_NAMES'][i]:
                                rule_or_index = i
                                is_rule = True
                                break
                        if rule_or_index[0] == "r" or rule_or_index[0] == "R" :
                            rule_or_index = rule_or_index.replace('r','').replace('R','')
                            try :
                                rule_or_index = int(rule_or_index)
                                is_rule = True
                            except :
                                print(bcolors.FAIL + "ERROR: '{}' is not a rule nor an index.".format(rule_or_index) + bcolors.ENDC)
                                return
                        if is_rule == False :
                            try :
                                rule_or_index = int(rule_or_index)
                            except :
                                print(bcolors.FAIL + "ERROR: '{}' is not a rule nor an index.".format(rule_or_index) + bcolors.ENDC)
                                return
                            if rule_or_index < 0 or rule_or_index >= len(RULES['REWRITE_RULES']):
                                print(bcolors.FAIL + "ERROR: no possible rewrite has index '{}'.".format(rule_or_index) + bcolors.ENDC)
                                return
                            display_all_possible_rewritings(last_proposition,MATCH_INDEX=rule_or_index)
                        else :
                            display_given_a_rule(last_proposition,RULE_INDEX=rule_or_index)
            elif len(PROP.split(' ')) == 3 :
                match PROP.split(' ')[1]:
                    case _ :
                        rule_index = PROP.split(' ')[1]
                        rule_found = False
                        for i in range(len(RULES['REWRITE_RULES_NAMES'])):
                            if rule_index == RULES['REWRITE_RULES_NAMES'][i]:
                                rule_index = i
                                rule_found = True
                                break
                        if rule_found == False and (rule_index[0] == "r" or rule_index[0] == "R") :
                            rule_index = rule_index.replace('r','').replace('R','')
                            try :
                                rule_index = int(rule_index)
                            except :
                                print(bcolors.FAIL + "ERROR: '{}' is not a rule.".format(rule_index) + bcolors.ENDC)
                                return
                        try :
                            rule_index = int(rule_index)
                        except:
                            print(bcolors.FAIL + "ERROR: no rule correspond to '{}'.".format(rule_or_index) + bcolors.ENDC)
                            return
                        if rule_found == False and (rule_index < 0 or rule_index >= len(RULES['REWRITE_RULES'])):
                            print(bcolors.FAIL + "ERROR: no rule has index '{}'.".format(rule_or_index) + bcolors.ENDC)
                            return
                        try :
                            match_index = int(PROP.split(' ')[2])
                        except :
                            print(bcolors.FAIL + "ERROR: '{}' is not a correct index.".format(match_index) + bcolors.ENDC)
                        display_given_a_rule(last_proposition,RULE_INDEX=rule_index,MATCH_INDEX=match_index)

        case "match" | "matches": # highlight rewritable parts of the token
            if len(PROP.split(' ')) == 1 :
                #display_rewritable_parts(last_proposition)
                display_rewritable_parts(last_proposition)
            elif len(PROP.split(' ')) == 2 :
                rule_to_match = PROP.split(' ')[1]
                display_rewritable_parts(last_proposition,RULE_TO_MATCH=rule_to_match)
            elif len(PROP.split(' ')) == 3 :
                rule_to_match = PROP.split(' ')[1]
                match_index = PROP.split(' ')[2]
                try :
                    match_index = int(match_index)
                except:
                    print(bcolors.FAIL + "ERROR: '{}' is not a valid match index.".format(match_index) + bcolors.ENDC)
                    return
                display_rewritable_parts(last_proposition,RULE_TO_MATCH=rule_to_match,MATCH_INDEX=match_index)
            else :
                print(bcolors.FAIL + "ERROR: match syntax is 'match [r0 [index]]'" + bcolors.ENDC)


        case "debug" :
            if len(PROP.split(' ')) != 2 :
                print("Need one thing to debug. For example : debug rules")
            else :
                match PROP.split(' ')[1] :
                    case "rules" : print(RULES)
                    case "rewrite" : print(RULES['REWRITE_RULES'])
                    case "axioms" : print(RULES['AXIOMS'])

        case "del" | "delete":
            if len(PROP.split(' ')) == 1 :
                print("INFO: Use 'delete x' or 'delete Rx' to delete a rule.")
                for i in range(len(RULES['REWRITE_RULES'])) :
                    print(bcolors.OKBLUE + "\t(R{}) \t{}".format(i,human_readable(RULES['REWRITE_RULES'][i])) + bcolors.ENDC)
            elif len(PROP.split(' ')) > 2 :
                print("ERROR: 'delete' needs precisely one rule number")
            else :
                del_rule_or_axiom(PROP.split(' ')[1])

        case "add" :
            if len(PROP.split(' ')) == 1 or len(PROP.split(' ')) > 2 : print("ERROR: ':add' needs precisely of those arguments: 'axiom', 'rule', 'proposition'")
            else :
                match PROP.split(' ')[1]:
                    case "axiom" | "a" :
                        add_axiom(multiple=False,last_proposition=last_proposition)
                    case "axioms" | "as" :
                        add_axiom(multiple=True)
                    case "rule" | "r":
                        add_rule(multiple=False,last_proposition=last_proposition)
                    case "rules" | "rs":
                        add_rule(multiple=True)
                    case "prop" | "p" | "proposition":
                        print("TODO")

        case "rename" :
            if len(PROP.split(' ')) != 3 : print("ERROR: 'rename' needs precisely two arguments: 'old_name', 'new_name'")
            else :
                found = False
                if "A" in PROP.split(' ')[1] or "a" in PROP.split(' ')[1]:
                    try:
                        index = int(PROP.split(' ')[1].replace("A","").replace("a",""))
                        RULES['AXIOMS_NAMES'][index] = PROP.split(' ')[2]
                        found = True
                    except : found = False
                elif "R" in PROP.split(' ')[1] or "r" in PROP.split(' ')[1]:
                    try:
                        index = int(PROP.split(' ')[1].replace("R","").replace("r",""))
                        RULES['REWRITE_RULES_NAMES'][index] = PROP.split(' ')[2]
                        found = True
                    except: found = False
                else :
                    for i in range(len(RULES['AXIOMS_NAMES'])):
                        if PROP.split(' ')[1] == RULES['AXIOMS_NAMES'][i] :
                            found = True
                            RULES['AXIOMS_NAMES'][i] = PROP.split(' ')[2]
                            break
                    if not found :
                        for i in range(len(RULES['REWRITE_RULES_NAMES'])):
                            if PROP.split(' ')[1] == RULES['REWRITE_RULES_NAMES'][i] :
                                found = True
                                RULES['REWRITE_RULES_NAMES'][i] = PROP.split(' ')[2]
                                break
                if not found : print("ERROR: no axiom nor rule with that index or name.")


        case "help":
            print("TODO: sorry, this help menu is not really helpful for now.")

        case _:
            #print(bcolors.FAIL + "ERROR: unknown command. See '{} --help' or ':help'.".format(sys.argv[0]) + bcolors.ENDC)
            cur_proposition = str(PROP)
            if PARSE(TOKENIZE(cur_proposition))[0]:
                last_proposition = cur_proposition
                user_propositions.append(last_proposition)

try :
    if sys.argv[1] :
        print(bcolors.OKBLUE + "TODO: {} will soon accept receiving arguments.".format(sys.argv[0]) + bcolors.ENDC)
except:
    pass

print(IDIOMATIK_GREETING)

while True:
    try :
        user_input = input(IDIOMATIK_PROMPT)
    except:
        print(bcolors.FAIL + "ERROR: Invalid characters in input." + bcolors.ENDC)
        continue
    proposition=str(user_input)
    evaluate_proposition(proposition)
