#!/usr/bin/env python3

# GOAL :
#Model = { 'R0 : A = B <=> B = A (swap)', 'P0 : "a" = "b"', 'P1 : "b" = "c"' }
#CHECK P1 : "a" = "c"

#RULES['AXIOMS'].append(RULE[1])
#RULES['REWRITE_RULES'].append(RULE[1])

import sys
from read_table import *
from lexer import *
from parser import *
from read_rules import *
from checker import *
from displayer import *
from rewriter import *
import readline # allow left/right arrow while inputing
from colors import *

sys.setrecursionlimit(10**6)

global last_proposition
last_proposition = ""
global user_propositions
user_propositions = []

IDIOMATIK_PROMPT   = bcolors.OKGREEN + '\n|> ' + bcolors.ENDC
IDIOMATIK_GREETING = bcolors.OKBLUE + '''
+---------------------------------------------------------------------+
|> Welcome to idiomatik! You can start writing expressions as inputs. |
|            Read the documentation (if any) to learn about commands. |
+---------------------------------------------------------------------+
''' + bcolors.ENDC

def add_rule(multiple=False,last_proposition=last_proposition):
    if multiple == True:
        try :
            last_proposition = input("    > ")
        except:
            print(bcolors.FAIL + "ERROR: Invalid characters in input." + bcolors.ENDC)
        if last_proposition == "" or last_proposition == ":q" :
            print(bcolors.ERASE_LINE + bcolors.ERASE_UP + bcolors.ERASE_LINE) # Erase empty prompt
            return
    elif last_proposition.replace(NULL,'') == "" :
        print("ERROR: empty proposition")
        return
    READ_RULES([last_proposition],add_axioms=False)
    if multiple :
        add_rule(multiple=True)

def add_axiom(multiple=False,last_proposition=last_proposition):
    if multiple == True:
        try :
            last_proposition = input("    > ")
        except:
            print(bcolors.FAIL + "ERROR: Invalid characters in input." + bcolors.ENDC)
        if last_proposition == "" or last_proposition == ":q" :
            print(bcolors.ERASE_LINE + bcolors.ERASE_UP + bcolors.ERASE_LINE) # Erase empty prompt
            return
    elif last_proposition.replace(NULL,'') == "" :
        print("ERROR: empty proposition")
        return
    READ_RULES([last_proposition],add_rules=False)
    if multiple :
        add_axiom(multiple=True)


def del_rule_or_axiom(user_value):
    # user_value = PROP.split(' ')[1]
    found = False
    for i in range(len(RULES['REWRITE_RULES'])) :
        if "R"+str(i) == user_value or \
            "r"+str(i) == user_value or \
            str(i) == user_value :
                found = True
                name = RULES['REWRITE_RULES_NAMES'][i]
                if name == "" : name = "empty name"
                print(bcolors.OKBLUE + "Deleted R{} ({}) {}".format(i,name,human_readable(RULES['REWRITE_RULES'][i])) + bcolors.ENDC)
                RULES['REWRITE_RULES'].pop(i)
                RULES['REWRITE_RULES_NAMES'].pop(i)
                break
    if found: return
    for i in range(len(RULES['REWRITE_RULES_NAMES'])) :
        if user_value == RULES['REWRITE_RULES_NAMES'][i] :
                name = RULES['REWRITE_RULES_NAMES'][i]
                if name == "" : name = "empty name"
                print(bcolors.OKBLUE + "Deleted '{}' (R{}) {}".format(name,i,human_readable(RULES['REWRITE_RULES'][i])) + bcolors.ENDC)
                RULES['REWRITE_RULES_NAMES'].pop(i)
                RULES['REWRITE_RULES'].pop(i)
                break
    if found: return
    for i in range(len(RULES['AXIOMS'])) :
        if "A"+str(i) == user_value or \
            "a"+str(i) == user_value or \
            str(i) == user_value :
                found = True
                name = RULES['AXIOMS_NAMES'][i]
                if name == "" : name = "empty name"
                print(bcolors.OKBLUE + "Deleted R{} ({}) {}".format(i,name,human_readable(RULES['AXIOMS'][i])) + bcolors.ENDC)
                RULES['AXIOMS'].pop(i)
                RULES['AXIOMS_NAMES'].pop(i)
                break
    if found: return
    for i in range(len(RULES['AXIOMS_NAMES'])) :
        if user_value == RULES['AXIOMS_NAMES'][i] :
                name = RULES['AXIOMS_NAMES'][i]
                if name == "" : name = "empty name"
                print(bcolors.OKBLUE + "Deleted '{}' (A{}) {}".format(name,i,human_readable(RULES['AXIOMS'][i])) + bcolors.ENDC)
                RULES['AXIOMS_NAMES'].pop(i)
                RULES['AXIOMS'].pop(i)
                break

def evaluate_proposition(PROP):
    global last_proposition
    '''
    If PROP starts with ':' then it is a COMMAND?
    '''
    #if PROP[0:1] == ":":
    #PROP = PROP.split(' ')
    match PROP.split(' ')[0]:
        case ":q" | "quit" | "exit" :
            exit(0)

        case "prop" | "proposition": # displays current proposition under scrutiny
            print(human_readable(TOKENIZE(last_proposition)))

        case "tok" | "token":
            try:
                print(TOKENIZE(last_proposition))
            except:
                print(bcolors.FAIL + "ERROR: you need to give an expression first." + bcolors.ENDC)

        case "tree" | "draw" :
            try :
                render_tree(TOKENIZE(last_proposition))
            except:
                print("ERROR: why no tree? TODO")

        case "surr" | "surrounding" :
            #try :
            #solving_surrounders = NULL.join(map(str, [x[1] for x in silent_surrounding(TOKENIZE(last_proposition))]))
            solving_surrounders = human_readable(silent_surrounding(TOKENIZE(last_proposition)))
            #print("Background surrounding : {}".format(solving_surrounders))
            print("{}".format(solving_surrounders))
            #except:
            #    print("ERROR: you need to give an expression first.")

        case "axioms":
            display_axioms_and_rules("axioms")

        case "rules":
            display_axioms_and_rules("rules")

        case "rewrite":
            if len(PROP.split(' ')) < 2 :
                    print(bcolors.WARNING + "Please provide a name or number for rewriting rule.\nOr use 'full' to combine them all." + bcolors.ENDC)
            else :
                match PROP.split(' ')[1]:
                    case "full" | "f" :
                        display_all_possible_rewritings(last_proposition)
                    case _ :
                        print(bcolors.WARNING + "TODO: something else than full rewrite" + bcolors.ENDC)

        case "match" | "matches": # highlight rewritable parts of the token
            if len(PROP.split(' ')) == 2 :
                #rule_index = PROP.split(' ')[1].replace('r','').replace('R','')
                rule_index = PROP.split(' ')[1]
                display_single_rewritable_parts(last_proposition,RULE_INDEX=rule_index)
            else :
                display_rewritable_parts(last_proposition)

        case "debug" :
            if len(PROP.split(' ')) != 2 :
                print("Need one thing to debug. For example : debug rules")
            else :
                match PROP.split(' ')[1] :
                    case "rules" : print(RULES)
                    case "rewrite" : print(RULES['REWRITE_RULES'])
                    case "axioms" : print(RULES['AXIOMS'])

        case "del" | "delete":
            if len(PROP.split(' ')) == 1 :
                print("INFO: Use 'delete x' or 'delete Rx' to delete a rule.")
                for i in range(len(RULES['REWRITE_RULES'])) :
                    print(bcolors.OKBLUE + "\t(R{}) \t{}".format(i,human_readable(RULES['REWRITE_RULES'][i])) + bcolors.ENDC)
            elif len(PROP.split(' ')) > 2 :
                print("ERROR: 'delete' needs precisely one rule number")
            else :
                del_rule_or_axiom(PROP.split(' ')[1])

        case "add" :
            if len(PROP.split(' ')) == 1 or len(PROP.split(' ')) > 2 : print("ERROR: ':add' needs precisely of those arguments: 'axiom', 'rule', 'proposition'")
            else :
                match PROP.split(' ')[1]:
                    case "axiom" | "a" :
                        add_axiom(multiple=False,last_proposition=last_proposition)
                    case "axioms" | "as" :
                        add_axiom(multiple=True)
                    case "rule" | "r":
                        add_rule(multiple=False,last_proposition=last_proposition)
                    case "rules" | "rs":
                        add_rule(multiple=True)
                    case "prop" | "p" | "proposition":
                        print("TODO")

        case "rename" :
            if len(PROP.split(' ')) != 3 : print("ERROR: 'rename' needs precisely two arguments: 'old_name', 'new_name'")
            else :
                found = False
                if "A" in PROP.split(' ')[1] or "a" in PROP.split(' ')[1]:
                    try:
                        index = int(PROP.split(' ')[1].replace("A","").replace("a",""))
                        RULES['AXIOMS_NAMES'][index] = PROP.split(' ')[2]
                        found = True
                    except : found = False
                elif "R" in PROP.split(' ')[1] or "r" in PROP.split(' ')[1]:
                    try:
                        index = int(PROP.split(' ')[1].replace("R","").replace("r",""))
                        RULES['REWRITE_RULES_NAMES'][index] = PROP.split(' ')[2]
                        found = True
                    except: found = False
                else :
                    for i in range(len(RULES['AXIOMS_NAMES'])):
                        if PROP.split(' ')[1] == RULES['AXIOMS_NAMES'][i] :
                            found = True
                            RULES['AXIOMS_NAMES'][i] = PROP.split(' ')[2]
                            break
                    if not found :
                        for i in range(len(RULES['REWRITE_RULES_NAMES'])):
                            if PROP.split(' ')[1] == RULES['REWRITE_RULES_NAMES'][i] :
                                found = True
                                RULES['REWRITE_RULES_NAMES'][i] = PROP.split(' ')[2]
                                break
                if not found : print("ERROR: no axiom nor rule with that index or name.")


        case "help":
            print("TODO: sorry, this help menu is not really helpful for now.")

        case _:
            #print(bcolors.FAIL + "ERROR: unknown command. See '{} --help' or ':help'.".format(sys.argv[0]) + bcolors.ENDC)
            cur_proposition = str(PROP)
            if PARSE(TOKENIZE(cur_proposition))[0]:
                last_proposition = cur_proposition
                user_propositions.append(last_proposition)

try :
    if sys.argv[1] :
        print(bcolors.OKBLUE + "TODO: {} will soon accept receiving arguments.".format(sys.argv[0]) + bcolors.ENDC)
except:
    pass

print(IDIOMATIK_GREETING)

while True:
    try :
        user_input = input(IDIOMATIK_PROMPT)
    except:
        print(bcolors.FAIL + "ERROR: Invalid characters in input." + bcolors.ENDC)
        continue
    proposition=str(user_input)
    evaluate_proposition(proposition)
